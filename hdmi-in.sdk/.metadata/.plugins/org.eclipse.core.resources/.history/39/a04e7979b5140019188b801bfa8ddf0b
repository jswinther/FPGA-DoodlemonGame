/*
 * interrupt_COUNTER_TIMEKEEPING_tut_2B.c
 *
 *  Version 1.2 Author : Edward Todirica
 *
 *  Created on: 	Unknown
 *      Author: 	Ross Elliot
 *     Version:		1.1
 */

/********************************************************************************************

* VERSION HISTORY
********************************************************************************************
*   v1.2 - 10.11.2016
*		Fixed some bugs regarding Timer Interrupts and adding some
*       debug messages for the Timer Interrupt Handler
*
* 	v1.1 - 01/05/2015
* 		Updated for Zybo ~ DN
*
*	v1.0 - Unknown
*		First version created.
*******************************************************************************************/

// Library Definitions.
#include <stdio.h>
#include "xparameters.h"
#include "xgpio.h"
#include "xtmrctr.h"
#include "xscugic.h"
#include "xil_exception.h"
#include "xil_printf.h"
#include "xtime_l.h"
#include <stdlib.h>

// Parameter definitions
#define INTC_DEVICE_ID 		XPAR_PS7_SCUGIC_0_DEVICE_ID
#define TMR_DEVICE_ID		XPAR_TMRCTR_0_DEVICE_ID
#define BTNS_DEVICE_ID		XPAR_AXI_GPIO_0_DEVICE_ID
#define LEDS_DEVICE_ID		XPAR_AXI_GPIO_1_DEVICE_ID
#define SWS_DEVICE_ID		XPAR_AXI_GPIO_2_DEVICE_ID
#define INTC_GPIO_0_INTERRUPT_ID XPAR_FABRIC_AXI_GPIO_0_IP2INTC_IRPT_INTR
#define INTC_GPIO_2_INTERRUPT_ID XPAR_FABRIC_AXI_GPIO_2_IP2INTC_IRPT_INTR
#define INTC_TMR_INTERRUPT_ID XPAR_FABRIC_AXI_TIMER_0_INTERRUPT_INTR
#define BTN_INT 			XGPIO_IR_CH1_MASK
#define SW_INT 				XGPIO_IR_CH1_MASK
#define TMR_LOAD			100000000

enum BUTTONS {
	A = 1,
	C = 4,
	L = 8
};

enum STATES{
	STATE_TIMEKEEPING,
	STATE_ALARM,
	STATE_STOPWATCH,
	STATE_SETTING
};

enum STATES_ALARM {
	ALARM_SET,
	ALARM_HOURS,
	ALARM_MINUTES
};

enum STATES_STOPWATCH {
	ZERO,
	START,
	STOP,
	RESTART
};

enum STATES_SETTING {
	IDLE,
	SECONDS,
	HOURS,
	MINUTES
};

enum TIME {
	SECOND = 1,
	MINUTE = 60,
	HOUR = 3600
};

enum QUICK_ADVANCE {
	A_ZERO,
	A_ONE,
	A_TWO
};

enum STATES STATE = STATE_TIMEKEEPING;
enum STATES_ALARM STATES_OF_ALARM = ALARM_SET;
enum STATES_STOPWATCH STATES_OF_STOPWATCH = ZERO;
enum STATES_SETTING STATES_OF_SETTING = IDLE;
enum BUTTONS BUTTON;
enum QUICK_ADVANCE A_STATE;



// Allocating GPIO Variables.
XGpio LEDInst, BTNInst, SWInst;

// Allocating Interrupt Controller.
XScuGic INTCInst;

// Enable Signals.
int enable;
int FLAG_TIMEKEEPING;
int FLAG_ALARM;
int FLAG_STOPWATCH;
int FLAG_SETTING;

// Timekeeping Variables.
int COUNTER_TIMEKEEPING = 0;
int COUNTER_STOPWATCH = 0;
int COUNTER_ALARM = 0;
int COUNTER_SETTING = 0;



// IO
int state; //Gammel led data.
int btn_value;
int sw_value;

XTime tStart, tEnd;

//----------------------------------------------------
// PROTOTYPE FUNCTIONS
//----------------------------------------------------
void BTN_Intr_Handler(void *baseaddr_p);
void SW_Intr_Handler(void *baseaddr_p);
void TMR_Intr_Handler(void *InstancePtr, u8 TmrCtrNumber);
int InterruptSystemSetup(XScuGic *XScuGicInstancePtr);
int IntcInitFunction(u16 DeviceId, XTmrCtr *TmrInstancePtr, XGpio *GpioInstancePtr);
void intToASCII(int Int);
void Timekeeping(void);
void Alarm(void);
void Stopwatch(void);
void Setting(void);



/*****************************************************************************/
/**
* This function should be part of the device driver for the timer device
* Clears the interrupt flag of the specified timer COUNTER_TIMEKEEPING of the device.
* This is necessary to do in the interrupt routine after the interrupt was handled.
*
* @param	InstancePtr is a pointer to the XTmrCtr instance.
* @param	TmrCtrNumber is the timer COUNTER_TIMEKEEPING of the device to operate on.
*		Each device may contain multiple timer COUNTER_TIMEKEEPINGs. The timer
*		number is a zero based number  with a range of
*		0 - (XTC_DEVICE_TIMER_COUNT - 1).
*
* @return	None.
*
* @note		None.
*
******************************************************************************/
void XTmrCtr_ClearInterruptFlag(XTmrCtr * InstancePtr, u8 TmrCtrNumber)
{
	u32 COUNTER_TIMEKEEPINGControlReg;
	Xil_AssertVoid(InstancePtr != NULL);
	Xil_AssertVoid(TmrCtrNumber < XTC_DEVICE_TIMER_COUNT);
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
	/*
	 * Read current contents of the CSR register so it won't be destroyed
	 */
	COUNTER_TIMEKEEPINGControlReg = XTmrCtr_ReadReg(InstancePtr->BaseAddress, TmrCtrNumber, XTC_TCSR_OFFSET);
	/*
	 * Reset the interrupt flag
	 */
	XTmrCtr_WriteReg(InstancePtr->BaseAddress, TmrCtrNumber,XTC_TCSR_OFFSET,COUNTER_TIMEKEEPINGControlReg | XTC_CSR_INT_OCCURED_MASK);
}



//----------------------------------------------------
// INTERRUPT HANDLER FUNCTIONS
// - called by the timer, button interrupt, performs
// - LED flashing
//----------------------------------------------------


void BTN_Intr_Handler(void *InstancePtr)
{
	A_STATE = A_ZERO;

	// Disable GPIO interrupts
	XGpio_InterruptDisable(&BTNInst, BTN_INT);
	// Ignore additional button presses
	if ((XGpio_InterruptGetStatus(&BTNInst) & BTN_INT) != BTN_INT) {
			return;
	}
	BUTTON = XGpio_DiscreteRead(&BTNInst, 1);
	// Increment COUNTER_TIMEKEEPING based on button value
	// Reset if centre button pressed
	switch(BUTTON) {
	case A:
		switch(STATE) {
		case STATE_TIMEKEEPING:
			break;
		case STATE_ALARM:
			switch(STATES_OF_ALARM) {
			case ALARM_SET:
				break;
			case ALARM_HOURS:
				COUNTER_ALARM = COUNTER_ALARM + HOUR;
				break;
			case ALARM_MINUTES:
				COUNTER_ALARM = COUNTER_ALARM + MINUTE;
				break;
			default:
				break;
			}
			break;
		case STATE_STOPWATCH:
			switch(STATES_OF_STOPWATCH) {
			case ZERO:
				COUNTER_STOPWATCH = 0;
				FLAG_STOPWATCH = 1;
				STATES_OF_STOPWATCH = START;
				break;
			case START:
				FLAG_STOPWATCH = 0;
				STATES_OF_STOPWATCH = STOP;
				break;
			case STOP:
				FLAG_STOPWATCH = 1;
				STATES_OF_STOPWATCH = RESTART;
				break;
			case RESTART:
				FLAG_STOPWATCH = 0;
				STATES_OF_STOPWATCH = STOP;
				break;
			default:
				break;

			}
			break;
			/*
			if(FLAG_STOPWATCH == 0) {
				FLAG_STOPWATCH = 1;
			} else {
				FLAG_STOPWATCH = 0;
			}
			*/


		case STATE_SETTING:
			switch(STATES_OF_SETTING) {
			case IDLE:
				STATES_OF_SETTING = SECONDS;
				break;
			case SECONDS:
				COUNTER_SETTING = COUNTER_SETTING + SECOND;
				break;
			case HOURS:
				COUNTER_SETTING = COUNTER_SETTING + HOUR;
				break;
			case MINUTES:
				COUNTER_SETTING = COUNTER_SETTING + MINUTE;
				break;
			default:
				break;
			}
			break;
		}
		break;
	case C:
		switch(STATE) {
		case STATE_TIMEKEEPING:
			STATE = STATE_ALARM;
			break;
		case STATE_STOPWATCH:
			STATE = STATE_SETTING;
			break;
		case STATE_ALARM:
			if(FLAG_SETTING == 0)
				COUNTER_SETTING = 0;
			FLAG_SETTING = 0;
			STATE = STATE_STOPWATCH;
			break;
		case STATE_SETTING:
			if(FLAG_SETTING == 1)
				COUNTER_TIMEKEEPING = COUNTER_SETTING;
			STATE = STATE_TIMEKEEPING;
			break;
		}
		break;
	case L:
		switch(STATE) {
		case STATE_TIMEKEEPING:
			break;
		case STATE_ALARM:
			switch(STATES_OF_ALARM) {
			case ALARM_SET:
				STATES_OF_ALARM = ALARM_HOURS;
				break;
			case ALARM_HOURS:
				STATES_OF_ALARM = ALARM_MINUTES;
				break;
			case ALARM_MINUTES:
				FLAG_ALARM = 1;
				STATES_OF_ALARM = ALARM_SET;
				break;
			default:
				break;
			}
			break;
		case STATE_STOPWATCH:
			switch(STATES_OF_STOPWATCH) {
			case ZERO:
				break;
			case START:
				break;
			case STOP:
				COUNTER_STOPWATCH = 0;
				STATES_OF_STOPWATCH = ZERO;
				break;
			case RESTART:
				break;
			default:
				break;

			}

			break;

		case STATE_SETTING:
			switch(STATES_OF_SETTING) {
			case IDLE:
				break;
			case SECONDS:
				STATES_OF_SETTING = HOURS;
				break;
			case HOURS:
				STATES_OF_SETTING = MINUTES;
				break;
			case MINUTES:
				FLAG_SETTING = 1;
				STATES_OF_SETTING = IDLE;
				break;
			default:
				break;
			}
			break;
		}
		break;
	default:
		break;
	}




    (void)XGpio_InterruptClear(&BTNInst, BTN_INT);
    // Enable GPIO interrupts
    XGpio_InterruptEnable(&BTNInst, BTN_INT);
}

void SW_Intr_Handler(void *InstancePtr)
{
	// Disable GPIO interrupts
	XGpio_InterruptDisable(&SWInst, SW_INT);
	// Ignore additional button presses
	if ((XGpio_InterruptGetStatus(&SWInst) & SW_INT) !=
			SW_INT) {
			return;
		}
	sw_value = XGpio_DiscreteRead(&SWInst, 1);

	// Increment COUNTER_TIMEKEEPING based on button value
	// Reset if centre button pressed
    (void)XGpio_InterruptClear(&SWInst, SW_INT);
    // Enable GPIO interrupts
    XGpio_InterruptEnable(&SWInst, SW_INT);
}

void TMR_Intr_Handler(void *InstancePtr, u8 TmrCtrNumber)
{
	XTime_GetTime(&tEnd);
	XTmrCtr* pTMRInst = (XTmrCtr *) InstancePtr;
	if (TmrCtrNumber==0) { //Handle interrupts generated by timer 0
		tStart=tEnd;
		if (XTmrCtr_IsExpired(pTMRInst,0)) {
			COUNTER_TIMEKEEPING++;
			enable = 1;
		}
	}
	XTmrCtr_ClearInterruptFlag(pTMRInst, TmrCtrNumber);
}



//----------------------------------------------------
// MAIN FUNCTION
//----------------------------------------------------
int main (void)
{
  int status;
  XTmrCtr TMRInst;
  //----------------------------------------------------
  // INITIALIZE THE PERIPHERALS & SET DIRECTIONS OF GPIO
  //----------------------------------------------------
  // Initialise LEDs
  status = XGpio_Initialize(&LEDInst, LEDS_DEVICE_ID);
  if(status != XST_SUCCESS) return XST_FAILURE;
  // Initialise Push Buttons
  status = XGpio_Initialize(&BTNInst, BTNS_DEVICE_ID);
  if(status != XST_SUCCESS) return XST_FAILURE;
  // Initialise Switches
  status = XGpio_Initialize(&SWInst, SWS_DEVICE_ID);
  if(status != XST_SUCCESS) return XST_FAILURE;
  // Set LEDs direction to outputs
  XGpio_SetDataDirection(&LEDInst, 1, 0x00);
  // Set all buttons direction to inputs
  XGpio_SetDataDirection(&BTNInst, 1, 0xFF);
  // Set all buttons direction to inputs
  XGpio_SetDataDirection(&SWInst, 1, 0xFF);
  //----------------------------------------------------
  // SETUP THE TIMER
  //----------------------------------------------------
  status = XTmrCtr_Initialize(&TMRInst, TMR_DEVICE_ID);
  if(status != XST_SUCCESS) return XST_FAILURE;
  XTmrCtr_SetHandler(&TMRInst, TMR_Intr_Handler, &TMRInst);
  XTmrCtr_SetResetValue(&TMRInst, 0, TMR_LOAD); //Variable that determines time.
  XTmrCtr_SetOptions(&TMRInst, 0, XTC_INT_MODE_OPTION | XTC_AUTO_RELOAD_OPTION | XTC_DOWN_COUNT_OPTION);

  // Initialize interrupt controller
  status = IntcInitFunction(INTC_DEVICE_ID, &TMRInst, &BTNInst);
  status = IntcInitFunction(INTC_DEVICE_ID, &TMRInst, &SWInst);
  if(status != XST_SUCCESS) return XST_FAILURE;
  XTmrCtr_Start(&TMRInst, 0);
  //Here we get the time when the timer first started
  XTime_GetTime(&tStart);

  while(1){

	  if(BUTTON == A) {
		  switch(A_STATE) {
		  case A_ZERO:
			  if(enable == 1)
			  A_STATE = A_ONE;
			  break;
		  case A_ONE:
			  if(enable == 1)
			  A_STATE = A_TWO;
			  break;
		  case A_TWO:
			  XTmrCtr_SetResetValue(&TMRInst, 0, TMR_LOAD/10); //Variable that determines time.
			  switch(STATE) {
			  case STATE_TIMEKEEPING:
				  break;
			  case STATE_ALARM:
				  switch(STATES_OF_ALARM) {
				  case ALARM_SET:
					  break;
				  case ALARM_HOURS:
					  if(enable == 1)
						  COUNTER_ALARM = COUNTER_ALARM + HOUR;
					  break;
				  case ALARM_MINUTES:
					  if(enable == 1)
						  COUNTER_ALARM = COUNTER_ALARM + MINUTE;
					  break;
				  }
				  break;
			  case STATE_STOPWATCH:
				  break;
			  case STATE_SETTING:
				  switch(STATES_OF_SETTING) {
				  case IDLE:
					  break;
				  case SECONDS:
					  if(enable == 1)
						  COUNTER_SETTING = COUNTER_SETTING + SECOND;
					  break;
				  case HOURS:
					  if(enable == 1)
						  COUNTER_SETTING = COUNTER_SETTING + HOUR;
					  break;
				  case MINUTES:
					  if(enable == 1)
						  COUNTER_SETTING = COUNTER_SETTING + MINUTE;
					  break;
				  default:
					  break;
				  }
				  break;
			  }

			  break;
		  default:
			  break;
		  }
	  } else if(sw_value == 0) {
		  XTmrCtr_SetResetValue(&TMRInst, 0, TMR_LOAD); //Variable that determines time.
	  } else if(sw_value == 1) {
		  XTmrCtr_SetResetValue(&TMRInst, 0, TMR_LOAD/10); //Variable that determines time.
	  } else if(sw_value <= 3) {
		  XTmrCtr_SetResetValue(&TMRInst, 0, TMR_LOAD/20); //Variable that determines time.
	  } else if(sw_value <= 7) {
		  XTmrCtr_SetResetValue(&TMRInst, 0, TMR_LOAD/30); //Variable that determines time.
	  } else if(sw_value >= 8) {
		  XTmrCtr_SetResetValue(&TMRInst, 0, TMR_LOAD/60); //Variable that determines time.
	  }





	  switch(STATE) {
	  case STATE_TIMEKEEPING:
		  XGpio_DiscreteWrite(&LEDInst, 1, 1);
		  if(enable == 1)
		  Timekeeping();
		  enable = 0;
		  break;
	  case STATE_ALARM:
		  XGpio_DiscreteWrite(&LEDInst, 1, 2);
		  if(enable == 1)
		  Alarm();
		  enable = 0;
		  break;
	  case STATE_STOPWATCH:
		  XGpio_DiscreteWrite(&LEDInst, 1, 4);
		  if(enable == 1)
		  Stopwatch();
		  enable = 0;
		  break;
	  case STATE_SETTING:
		  XGpio_DiscreteWrite(&LEDInst, 1, 8);
		  if(enable == 1)
		  Setting();
		  enable = 0;
		  break;
	  default:
		  if(enable == 1)
		  Timekeeping();
		  enable = 0;
		  break;
	  }
  };
  return 0;
}





void Timekeeping(void) {
	printf("Button Value: %d\n", BUTTON);
	printf("TIMEKEEPING\n");
	if(COUNTER_TIMEKEEPING == 24*HOUR) {
			  COUNTER_TIMEKEEPING = 0;
		  }
	intToASCII(COUNTER_TIMEKEEPING);
	FLAG_TIMEKEEPING = 0;
	if(FLAG_ALARM == 1)
	if(COUNTER_TIMEKEEPING == COUNTER_ALARM) {
		printf("#################\nALARM WENT OFF\n#################\n");
		FLAG_ALARM = 0;
	}
}

void Alarm(void) {
	printf("ALARM\n");
	if(COUNTER_ALARM == 24*HOUR) {
				  COUNTER_ALARM = 0;
			  }
	intToASCII(COUNTER_ALARM);
}

void Stopwatch(void) {
	printf("STOPWATCH\n");
	intToASCII(COUNTER_STOPWATCH);
	if(FLAG_STOPWATCH == 1)
			COUNTER_STOPWATCH++;
}

void Setting(void) {
	printf("SETTING\n");
	intToASCII(COUNTER_SETTING);
}

//----------------------------------------------------
// INITIAL SETUP FUNCTIONS
//----------------------------------------------------

int InterruptSystemSetup(XScuGic *XScuGicInstancePtr)
{
	// Enable interrupt
	XGpio_InterruptEnable(&BTNInst, BTN_INT);
	XGpio_InterruptEnable(&SWInst, SW_INT);
	XGpio_InterruptGlobalEnable(&BTNInst);
	XGpio_InterruptGlobalEnable(&SWInst);

	Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT,
	(Xil_ExceptionHandler)XScuGic_InterruptHandler,
	XScuGicInstancePtr);
	Xil_ExceptionEnable();


	return XST_SUCCESS;

}

int IntcInitFunction(u16 DeviceId, XTmrCtr *TmrInstancePtr, XGpio *GpioInstancePtr)
{
	XScuGic_Config *IntcConfig;
	int status;
	u8 pri, trig;

	// Interrupt controller initialisation
	IntcConfig = XScuGic_LookupConfig(DeviceId);
	status = XScuGic_CfgInitialize(&INTCInst, IntcConfig, IntcConfig->CpuBaseAddress);
	if(status != XST_SUCCESS) return XST_FAILURE;

	// Call to interrupt setup
	status = InterruptSystemSetup(&INTCInst);
	if(status != XST_SUCCESS) return XST_FAILURE;
	
	// Connect GPIO interrupt to handler
	status = XScuGic_Connect(&INTCInst,
					  	  	 INTC_GPIO_0_INTERRUPT_ID,
					  	  	 (Xil_ExceptionHandler)BTN_Intr_Handler,
					  	  	 (void *)GpioInstancePtr);
	if(status != XST_SUCCESS) return XST_FAILURE;
	// Connect GPIO interrupt to handler
	status = XScuGic_Connect(&INTCInst,
					  	  	 INTC_GPIO_2_INTERRUPT_ID,
					  	  	 (Xil_ExceptionHandler)SW_Intr_Handler,
					  	  	 (void *)GpioInstancePtr);
	if(status != XST_SUCCESS) return XST_FAILURE;

	// Connect timer interrupt to handler
	status = XScuGic_Connect(&INTCInst,
							 INTC_TMR_INTERRUPT_ID,
							// (Xil_ExceptionHandler)TMR_Intr_Handler,
							 (Xil_ExceptionHandler) XTmrCtr_InterruptHandler,
							 (void *)TmrInstancePtr);
	if(status != XST_SUCCESS) return XST_FAILURE;

	// Enable GPIO interrupts interrupt
	XGpio_InterruptEnable(GpioInstancePtr, 1);
	XGpio_InterruptGlobalEnable(GpioInstancePtr);

	// Enable GPIO and timer interrupts in the controller
	XScuGic_Enable(&INTCInst, INTC_GPIO_0_INTERRUPT_ID);
	XScuGic_Enable(&INTCInst, INTC_GPIO_2_INTERRUPT_ID);
	XScuGic_Enable(&INTCInst, INTC_TMR_INTERRUPT_ID);

	xil_printf("Getting the Timer interrupt info\n\r");
	XScuGic_GetPriTrigTypeByDistAddr(INTCInst.Config->DistBaseAddress, INTC_TMR_INTERRUPT_ID, &pri, &trig);
	xil_printf("GPIO Interrupt-> Priority:%d, Trigger:%x\n\r", pri, trig);

	
	//Set the timer interrupt as edge triggered
	//XScuGic_SetPriorityTriggerType(&INTCInst, INTC_TMR_INTERRUPT_ID, )

	return XST_SUCCESS;
}

void intToASCII(int Int) {

	int tid[6] = {0, 0, 0, 0, 0, 0};
	while(Int >= 3600) {
		if(tid[0] == 2 && tid[1] == 3) {
			tid[0] = 0;
			tid[1] = 0;
			tid[2] = 0;
			tid[3] = 0;
			tid[4] = 0;
			tid[5] = 0;
			Int-=3600;
		}
		if(tid[1] == 9) {
			tid[0]+=1;
			tid[1]=0;
			Int-=3600;
		} else if(Int >= 3600) {
			tid[1]+=1;
			Int-=3600;
		}
	}
	while(Int >= 60) {
		if(tid[3] == 9) {
			tid[2]+=1;
			tid[3]=0;
			Int-=60;
		} else {
			tid[3]+=1;
			Int-=60;
		}
	}
	while(Int > 0) {
		if(tid[5] == 9) {
			tid[4]+=1;
			tid[5]=0;
			Int-=1;
		} else {
			tid[5]+=1;
			Int-=1;
		}
	}

	char array1[7][10][8] =
		     {
		          {"00000","    0","00000","00000","0   0","00000","00000","00000","00000","00000"},
		          {"0   0","    0","    0","    0","0   0","0    ","0    ","    0","0   0","0   0"},
		          {"0   0","    0","    0","    0","0   0","0    ","0    ","    0","0   0","0   0"},
		          {"0   0","    0","00000","00000","00000","00000","00000","    0","00000","00000"},
		          {"0   0","    0","0    ","    0","    0","    0","0   0","    0","0   0","    0"},
		          {"0   0","    0","0    ","    0","    0","    0","0   0","    0","0   0","    0"},
		          {"00000","    0","00000","00000","    0","00000","00000","    0","00000","00000"},
		     };
	char array2[7][10][8] =
			 {
				  {"    ","    ","    ","    ","    ","    ","    ","    ","    ","    "},
				  {"    ","    ","    ","    ","    ","    ","    ","    ","    ","    "},
			      {"0000","   0","0000","0000","0  0","0000","0000","0000","0000","0000"},
			      {"0  0","   0","   0","   0","0  0","0   ","0   ","   0","0  0","0  0"},
			      {"0  0","   0","0000","0000","0000","0000","0000","   0","0000","0000"},
			      {"0  0","   0","0   ","   0","   0","   0","0  0","   0","0  0","   0"},
			      {"0000","   0","0000","0000","   0","0000","0000","   0","0000","0000"},
			     };
	    int i, j;
	    for(i = 0; i < 7; i++) {
	        for (j = 0;j < 6; j++) {
	        	if(j < 4) {
		        	printf("%s", array1[i][tid[j]]);
		        	if((j == 0) | (j == 2) | (j == 4)) {
		        		printf("  ");
		        	}
		        	else if(((i == 1) | (i == 2)| (i == 4) | (i == 5)) && ((j == 1))) {
		        		printf("  00  ");
		        	} else {
		        		printf("      ");
		        	}
	        	} else {
	        		printf("%s", array2[i][tid[j]]);
	        		printf("  ");
	        	}

	        }
	        printf("\n\r<");
	      }
	    printf("\n\n\r");
}



